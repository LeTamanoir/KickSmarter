#import "./types.jsligo" "TYPES"
namespace Kicksmarter {
  type post_project_param = {
    cid_metadata: string,
    milestones: list<TYPES.milestone>,
    funding_due_date: timestamp
  };
  /* @entry */
  const post_project = (param: post_project_param, storage: TYPES.storage)
    : [list<operation>, TYPES.storage] => {
    assert_with_error(
      String.length(param.cid_metadata) > (0 as nat),
      "metadata must be non-empty"
    );
    assert_with_error(
      List.length(param.milestones) > (0 as nat),
      "milestones must be non-empty"
    );
    assert_with_error(
      param.funding_due_date > Tezos.get_now(),
      "fundingDueDate must be in the future"
    );
    let old_start_date: timestamp = Tezos.get_now();
    let old_due_date: timestamp = old_start_date + 1;
    for (const m of param.milestones) {
      assert_with_error(
        m.required_amount > (0 as tez),
        "milestone requiredAmount must be positive"
      );
      assert_with_error(
        m.start_date > old_start_date,
        "milestone startDate must be in the future"
      );
      assert_with_error(
        m.due_date > old_due_date,
        "milestone dueDate must be in the future"
      );
      old_start_date = old_due_date + 1;
      old_due_date = m.due_date
    };
    let milestones_map: map<nat, TYPES.milestone> = Map.empty;
    for (const m of param.milestones) {
      let count = 0 as nat;
      milestones_map = Map.update(count, Some(m), milestones_map)
    };
    const sender = Tezos.get_sender();
    const new_projet_id = storage.total_projects;
    let target_amount: tez = 0 as tez;
    for (const m of param.milestones) {
      target_amount += m.required_amount
    };
    let new_project: TYPES.project =
      {
        id: new_projet_id,
        owner: sender,
        cid_metadata: param.cid_metadata,
        milestones: milestones_map,
        votes: Map.empty,
        target_amount: target_amount,
        current_amount: 0 as tez,
        investors: Map.empty,
        funding_start_date: Tezos.get_now(),
        funding_due_date: param.funding_due_date
      };
    const new_addr_to_projects =
      match(
        Big_map.find_opt(sender, storage.addr_to_projects),
        {
          Some: (projects) => list([new_projet_id, ...projects]),
          None: () => list([new_projet_id])
        }
      );
    const new_project_maker: TYPES.project_maker =
      match(
        Big_map.find_opt(sender, storage.project_makers),
        {
          Some: (maker) =>
            {
              nb_project_in_progress: maker.nb_project_in_progress + (1 as nat),
              nb_total_projects: maker.nb_total_projects + (1 as nat)
            },
          None: () =>
            { nb_project_in_progress: 0 as nat, nb_total_projects: 0 as nat }
        }
      );
    const new_storage =
      {
        ...storage,
        project_makers: Big_map.update(
          sender,
          Some(new_project_maker),
          storage.project_makers
        ),
        projects: Big_map.update(
          new_projet_id,
          Some(new_project),
          storage.projects
        ),
        addr_to_projects: Big_map.update(
          sender,
          Some(new_addr_to_projects),
          storage.addr_to_projects
        ),
        total_projects: storage.total_projects + (1 as nat)
      };
    return [list([]), new_storage]
  };
  type fund_project_param = { id: nat };
  /* @entry */
  const fund_project = (param: fund_project_param, storage: TYPES.storage)
    : [list<operation>, TYPES.storage] => {
    const amount: tez = Tezos.get_amount();
    assert_with_error(
      amount > (0 as tez),
      "sent amount must be at least 1 mutez"
    );
    const project =
      match(
        Big_map.find_opt(param.id, storage.projects),
        {
          Some: (project) => project,
          None: () => failwith("project not found")
        }
      );
    assert_with_error(
      Tezos.get_now() < project.funding_due_date,
      "Project funding period has ended"
    );
    assert_with_error(
      project.current_amount + amount <= project.target_amount,
      "Project is already fully funded"
    );
    const sender = Tezos.get_sender();
    const new_project_investors =
      match(
        Map.find_opt(sender, project.investors),
        {
          Some: (amount) =>
            Map.update(sender, Some(amount + amount), project.investors),
          None: () => Map.update(sender, Some(amount), project.investors)
        }
      );
    const new_project =
      {
        ...project,
        current_amount: project.current_amount + amount,
        investors: new_project_investors
      };
    const new_investors =
      match(
        Big_map.find_opt(sender, storage.investors),
        {
          Some: (investor) =>
            Big_map.update(
              sender,
              Some(
                {
                  total_invested_amount: investor.total_invested_amount + amount
                }
              ),
              storage.investors
            ),
          None: () =>
            Big_map.update(
              sender,
              Some({ total_invested_amount: amount }),
              storage.investors
            )
        }
      );
    const new_storage =
      {
        ...storage,
        projects: Big_map.update(param.id, Some(new_project), storage.projects),
        investors: new_investors
      };
    return [list([]), new_storage]
  };
  type desaprove_milestone_param = { id: nat, milestone_id: nat };
  /* @entry */
  const desaprove_milestone = (
    param: desaprove_milestone_param,
    storage: TYPES.storage
  ): [list<operation>, TYPES.storage] => {
    const project =
      match(
        Big_map.find_opt(param.id, storage.projects),
        {
          Some: (project) => project,
          None: () => failwith("project not found")
        }
      );
    match(
      Map.find_opt(param.milestone_id, project.milestones),
      { Some: (_) => unit, None: () => failwith("milestone not found") }
    );
    const sender = Tezos.get_sender();
    const weight =
      match(
        Map.find_opt(sender, project.investors),
        {
          Some: (weight) => weight,
          None: () => failwith("sender has not voted yet")
        }
      );
    const new_storage =
      {
        ...storage,
        projects: Big_map.update(
          param.id,
          Some(
            {
              ...project,
              votes: Map.update(
                param.milestone_id,
                Some(
                  match(
                    Map.find_opt(param.milestone_id, project.votes),
                    {
                      Some: (vote) =>
                        {
                          total_weight: vote.total_weight + weight,
                          voters: Set.add(sender, vote.voters)
                        },
                      None: () =>
                        {
                          total_weight: weight,
                          voters: Set.literal(list([sender]))
                        }
                    }
                  )
                ),
                project.votes
              )
            }
          ),
          storage.projects
        )
      };
    return [list([]), new_storage]
  }
};
